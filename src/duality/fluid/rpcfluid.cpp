/**
 * Copyright 2017 Everybody and Nobody Inc.
 * 
 * Permission is hereby granted, free of charge, to any person 
 * obtaining a copy of this software and associated documentation files 
 * (the "Software"), to deal in the Software without restriction, including 
 * without limitation the rights to use, copy, modify, merge, publish, 
 * distribute, sublicense, and/or sell copies of the Software, and to 
 * permit persons to whom the Software is furnished to do so, subject 
 * to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "fluidtoken.h"
#include "fluidkeys.h"

#include "amount.h"
#include "base58.h"
#include "chain.h"
#include "core_io.h"
#include "init.h"
#include "duality/keepass.h"
#include "main.h"
#include "net.h"
#include "netbase.h"
#include "policy/rbf.h"
#include "api/rpc/rpcserver.h"
#include "timedata.h"
#include "util.h"
#include "utilmoneystr.h"
#include "wallet/wallet.h"
#include "wallet/walletdb.h"

#include <univalue.h>

#include <stdint.h>

extern bool EnsureWalletIsAvailable(bool avoidException);
extern void InitiateFluidIssuanceAlert(std::string issuanceToken);

UniValue broadcastfluidtoken(const UniValue& params, bool fHelp)
{
    if (!EnsureWalletIsAvailable(fHelp))
        return NullUniValue;

    if (fHelp || params.size() != 1)
        throw std::runtime_error(
            "broadcastfluidtoken \"hextoken\"\n"
            "\nMint Fluid Tokens to an address on the network\n"
            "\nArguments:\n"
            "1. \"hextoken\"  (string, required) The Fluid issuance token generated by generatefluidissuetoken.\n"
            "\nExamples:\n"
            + HelpExampleCli("broadcastfluidtoken", "\"3135303030303030303030303A3A313439373533313333333A3A444151566568354E4E7936536A77634653774B31514B596741634D524D646336796F20494F61306A6C6B4E7865625449745564664D2F344242467652332F5065497533776357377752416B386970374D38425A484170374C744556616461554534497072682F4A796D4233397A49DF23FN9804Y541713165436B3D\"")
            + HelpExampleRpc("broadcastfluidtoken", "\"3135303030303030303030303A3A313439373533313333333A3A444151566568354E4E7936536A77634653774B31514B596741634D524D646336796F20494F61306A6C6B4E7865625449745564664D2F344242467652332F5065497533776357377752416B386970374D38425A484170374C744556616461554534497072682F4A796D4233397A49DF23FN9804Y541713165436B3D\"")
        );

    EnsureWalletIsUnlocked();

	if (!InitiateFluidVerify(fluidCore.sovreignAddress))
		throw JSONRPCError(RPC_TYPE_ERROR, "Attempting Illegal Operation - Credentials Absent!");
	
	SecureString magicKey;
	
	if (!DerivePrivateKey(fluidCore.sovreignAddress, magicKey))
		throw JSONRPCError(RPC_TYPE_ERROR, "Attempting Illegal Operation - Unable to derive private key!");

	if (!IsHex(params[0].get_str()))
		return false;
	
	// Don't use ConvertHex here
	int len = params[0].get_str().length();
	std::string decodedString;
	
	for(int i=0; i< len; i+=2)
	{
		std::string byte = params[0].get_str().substr(i,2);
		char chr = (char) (int)strtol(byte.c_str(), NULL, 16);
		decodedString.push_back(chr);
	}
	
	if(!VerifyAlertToken(decodedString))
		throw JSONRPCError(RPC_TYPE_ERROR, "Attempting Illegal Operation - Fluid Issuance Token Invalid!");
	
	InitiateFluidIssuanceAlert(params[0].get_str());

    return true;
}
 
/** Generate Fluid Issuance Token  */
UniValue generatefluidissuetoken(const UniValue& params, bool fHelp)
{
    if (!EnsureWalletIsAvailable(fHelp))
        return NullUniValue;
    
    if (fHelp || params.size() < 1 || params.size() > 3)
        throw std::runtime_error(
            "generatefluidissuetoken \"dynamicaddress\" \"amount\"\n"
            "\Generate Fluid Issuance Token that can be broadcasted by the network\n"
            "\nArguments:\n"
            "1. \"dynamicaddress\"  (string, required) The dynamic address to mint the coins toward.\n"
            "2. \"account\"         (numeric or string, required) The amount of coins to be minted.\n"
            "\nExamples:\n"
            + HelpExampleCli("generatefluidissuetoken", "\"D5nRy9Tf7Zsef8gMGL2fhWA9ZslrP4K5tf\" \"123.456\"")
            + HelpExampleRpc("generatefluidissuetoken", "\"D5nRy9Tf7Zsef8gMGL2fhWA9ZslrP4K5tf\", \"123.456\"")
        );

    EnsureWalletIsUnlocked();
    
    CDynamicAddress address(params[0].get_str());
    if (!address.IsValid())
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid Dynamic address");
    
    CAmount nAmount = AmountFromValue(params[1]);
    if (nAmount <= fluidCore.fluidMintingMinimum)
        throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send, too low");
    
	if (!InitiateFluidVerify(fluidCore.sovreignAddress))
		throw JSONRPCError(RPC_TYPE_ERROR, "Attempting Illegal Operation - Credentials Absent!");
	
	SecureString magicKey;
	std::string processedMessage;
	    
    if (!GenerateFluidToken(address, nAmount, processedMessage))
		throw JSONRPCError(RPC_TYPE_ERROR, "Unable to generate Fluid Token!");
    
    return processedMessage;
}

UniValue decipherfluidtoken(const UniValue& params, bool fHelp)
{
    if (!EnsureWalletIsAvailable(fHelp))
        return NullUniValue;

    if (fHelp || params.size() != 1)
        throw std::runtime_error(
            "decipherfluidtoken \"hextoken\"\n"
            "\nMint Fluid Tokens to an address on the network\n"
            "\nArguments:\n"
            "1. \"hextoken\"  (string, required) The Fluid issuance token generated by generatefluidissuetoken.\n"
            "\nExamples:\n"
            + HelpExampleCli("decipherfluidtoken", "\"3135303030303030303030303A3A313439373533313333333A3A444151566568354E4E7936536A77634653774B31514B596741634D524D646336796F20494F61306A6C6B4E7865625449745564664D2F344242467652332F5065497533776357377752416B386970374D38425A484170374C744556616461554534497072682F4A796D4233397A49DF23FN9804Y541713165436B3D\"")
            + HelpExampleRpc("decipherfluidtoken", "\"3135303030303030303030303A3A313439373533313333333A3A444151566568354E4E7936536A77634653774B31514B596741634D524D646336796F20494F61306A6C6B4E7865625449745564664D2F344242467652332F5065497533776357377752416B386970374D38425A484170374C744556616461554534497072682F4A796D4233397A49DF23FN9804Y541713165436B3D\"")
        );

    EnsureWalletIsUnlocked();

	if (!IsHex(params[0].get_str()))
		return false;
	
	// Don't use ConvertHex here
	int len = params[0].get_str().length();
	std::string decodedString;
	
	for(int i=0; i< len; i+=2)
	{
		std::string byte = params[0].get_str().substr(i,2);
		char chr = (char) (int)strtol(byte.c_str(), NULL, 16);
		decodedString.push_back(chr);
	}
	
	if(!VerifyAlertToken(decodedString))
		throw JSONRPCError(RPC_TYPE_ERROR, "Attempting Illegal Operation - Fluid Issuance Token Invalid!");
	
	CDynamicAddress address;
	int64_t amountOfCoins = FluidTokenIssuanceAmount(GetTime(), address, params[0].get_str());
	
	UniValue obj(UniValue::VOBJ);
    obj.push_back(Pair("token", params[0].get_str()));
    obj.push_back(Pair("mintcoins", amountOfCoins));
    obj.push_back(Pair("address", address.ToString()));
    
    return obj;
}
 
